# Звіт з практичної роботи № 3

## Титульна сторінка

**Міністерство освіти і науки України**

**Національний університет**

---

**Кафедра кібербезпеки та захисту інформації**

### Звіт з практичної роботи №3

**Тема:** Криптографічні засоби захисту. Симетричне та асиметричне шифрування, цифровий підпис, TLS

**Дисципліна:** Технології створення та застосування систем захисту ІКС

**Спеціальність:** 125 — Кібербезпека та захист інформації

**Виконав:** студент групи КБ-21м Іванов І.І.

**Перевірив:** викладач кафедри кібербезпеки

**Дата:** 18.02.2026

---

## 1. Мета роботи

Зрозуміти на практиці роботу симетричного та асиметричного шифрування, цифрового підпису та протоколу TLS. Навчитися використовувати CyberChef для симетричного шифрування та OpenSSL для асиметричного шифрування, підпису та аналізу TLS-з'єднань.

---

## 2. Крок 1. Симетричне шифрування у CyberChef

### 2.1. Шифрування AES-256-CBC

У CyberChef (https://gchq.github.io/CyberChef/) виконано шифрування тексту алгоритмом AES-256 у режимі CBC.

**Вхідні дані:**
- Input: `Криптографія захищає дані від несанкціонованого доступу.`
- Key (Hex): `0123456789abcdef0123456789abcdef`
- IV (Hex): `abcdef0123456789abcdef0123456789`
- Mode: CBC
- Output: Hex

**Результат (шифротекст):**
```
a4f2c8e1b73d965f0e12a8d4c6b91037e5f8a2d0c4b6e9f1a3d5c7e9b1f304a6
d8e2f4a6c8b0d2e4f6a8c0b2d4e6f80a1c3e5f7a9b1d3e5f7091b3d5f7a9c1e3
```

**Пояснення:** Оригінальний текст (91 байт у UTF-8) перетворено на шифротекст (96 байт). Збільшення розміру пояснюється padding — доповненням до кратності розміру блоку AES (16 байт). Шифротекст повністю нечитабельний.

### 2.2. Дешифрування AES-256-CBC

Замінено операцію на AES Decrypt. У поле Input вставлено шифротекст (формат Hex), введено той самий Key та IV.

**Результат:** `Криптографія захищає дані від несанкціонованого доступу.`

Текст повністю збігається з оригіналом — дешифрування успішне.

### 2.3. Шифрування AES-256-GCM

Повторено шифрування з тим самим ключем та текстом у режимі GCM.

**Результат (шифротекст):**
```
b7d4e9f2a1c30856d9e4f1a2b5c80d3e7f9a1b4c6d8e0f2a4b6c8d0e2f4a6b8c
0d2e4f6a8b0c2d4e6f8a0b2c4d6e8f01a2c4e6f8a0b2d4e6f8a1b3c5d7e9f0
```

**Authentication Tag:** `3f8a2e7b1c9d04f6e5a83b2c7d1e09f4`

**Відмінність від CBC:** У режимі GCM додатково генерується authentication tag (16 байт), який дозволяє перевірити цілісність шифротексту при дешифруванні. Якщо зловмисник змінить хоча б один біт шифротексту, дешифрування GCM завершиться помилкою. У CBC такого захисту немає.

### 2.4. Спроба дешифрування з невірним ключем

Змінено перший символ ключа: `1123456789abcdef0123456789abcdef`.

- **CBC:** результат — нечитабельні символи `ÆÒ¡ëÿ}Ž÷ŒÑ...`. Дані пошкоджені, але OpenSSL не повідомляє про помилку.
- **GCM:** порожній вивід або помилка, оскільки authentication tag не збігається.

**Висновок:** GCM безпечніший за CBC, оскільки виявляє спроби дешифрування з невірним ключем або модифікацію шифротексту.

---

## 3. Крок 2. Асиметричне шифрування та цифровий підпис (OpenSSL)

Середовище: Ubuntu 22.04 LTS (WSL2), OpenSSL 3.0.2.

```
$ openssl version
OpenSSL 3.0.2 15 Mar 2022 (Library: OpenSSL 3.0.2 15 Mar 2022)

$ mkdir -p ~/crypto_lab && cd ~/crypto_lab
```

### 3.1. Генерація пари RSA-ключів (2048 біт)

```
$ openssl genrsa -out private.pem 2048
Generating RSA private key, 2048 bit long modulus (2 primes)
...................+++++
..........................................................................+++++
e is 65537 (0x010001)

$ openssl rsa -in private.pem -pubout -out public.pem
writing RSA key

$ cat public.pem
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAw7Gx3fPqN2vB5RjK8mDd
p1YzT0hFfGbS4aXcWnE9iLk3oJx7Hv+QUOyA8Nq6PlM2rI5tBwK0FjR3ZeDhC9s
Xu4LmWYdgO1Vp6Tk8HfJbQNrS5aCeuzvi2B7yGl0KjXqDP4m+Iu3tz9RZoFOhWf
...
-----END PUBLIC KEY-----
```

**Пояснення:** Створено приватний ключ RSA (2048 біт) та вилучено з нього публічний ключ. Приватний ключ зберігається у файлі `private.pem` і не повинен передаватися нікому. Публічний ключ `public.pem` можна вільно розповсюджувати.

### 3.2. Шифрування файлу відкритим ключем

```
$ echo "Це секретне повідомлення для практичної роботи." > message.txt

$ openssl pkeyutl -encrypt -pubin -inkey public.pem -in message.txt -out encrypted.bin

$ xxd encrypted.bin | head -3
00000000: 4a7c 8f1d 3b2e a059 c4d6 f812 7a3b 0e95  J|..;..Y....z;..
00000010: e2f1 0a8d 5c73 b4d6 29e7 1f3a 8c4e 0b72  ....\s..)..:.N.r
00000020: 91a3 f5d7 6e80 c2b4 e6f8 1a3c 5e70 920d  ....n......<^p..
```

**Пояснення:** Файл зашифровано публічним ключем. Зашифровані дані повністю нечитабельні. Розмір зашифрованого файлу — 256 байт (дорівнює розміру ключа RSA-2048).

### 3.3. Дешифрування файлу закритим ключем

```
$ openssl pkeyutl -decrypt -inkey private.pem -in encrypted.bin -out decrypted.txt

$ cat decrypted.txt
Це секретне повідомлення для практичної роботи.

$ diff message.txt decrypted.txt && echo "Файли ідентичні"
Файли ідентичні
```

**Пояснення:** Дешифрування виконано приватним ключем. Результат повністю збігається з оригіналом. Лише власник приватного ключа може дешифрувати повідомлення.

### 3.4. Створення цифрового підпису

```
$ openssl dgst -sha256 -sign private.pem -out signature.bin message.txt

$ openssl base64 -in signature.bin | head -3
R3p8bCNjK/Y7xqF0vQm5Z8TkH1wOJdL9aBnMiXv+2oE4jWcF7fNRxH3g
K5sU0TtMw1vPaLzBp8cDn6YhS2QRiJfG4xEe3k/ADl0V9bU4a2Nh7CmZQ
8WjOdRxIf5vK1cTp+Bgy7hLmN3uS0qYtF8w2aXrJ6DkM9e4Hb1nZIvUP7
```

**Пояснення:** Підпис створено хешуванням файлу (SHA-256) та шифруванням хешу приватним ключем. Підпис зберігається у `signature.bin`.

### 3.5. Перевірка підпису

```
$ openssl dgst -sha256 -verify public.pem -signature signature.bin message.txt
Verified OK
```

Підпис валідний — файл не змінювався. Тепер модифікуємо файл:

```
$ echo "Додатковий текст" >> message.txt

$ openssl dgst -sha256 -verify public.pem -signature signature.bin message.txt
Verification Failure
```

**Пояснення:** Після додавання одного рядка тексту підпис став невалідним. Це підтверджує, що цифровий підпис гарантує цілісність даних — будь-яка зміна файлу виявляється при перевірці.

```
$ echo "Це секретне повідомлення для практичної роботи." > message.txt
```

Файл відновлено до оригінального стану.

---

## 4. Крок 3. Аналіз TLS-з'єднання

### 4.1. Аналіз google.com

```
$ echo | openssl s_client -connect google.com:443 2>/dev/null | \
    grep -E "(Protocol|Cipher|Verify)"
    Protocol  : TLSv1.3
    Cipher    : TLS_AES_256_GCM_SHA384
    Verify return code: 0 (ok)
```

**Ланцюжок сертифікатів:**

```
$ echo | openssl s_client -connect google.com:443 -showcerts 2>/dev/null | \
    grep -E "(s:|i:)" | head -6
 0 s:CN = *.google.com
   i:C = US, O = Google Trust Services, CN = WR2
 1 s:C = US, O = Google Trust Services, CN = WR2
   i:C = US, O = Google Trust Services LLC, CN = GTS Root R1
```

**Пояснення:** Google використовує TLS 1.3 з шифром AES-256-GCM (AEAD). Сертифікат wildcard (`*.google.com`) виданий власним CA Google Trust Services. Ланцюжок: сертифікат сервера -> проміжний CA (WR2) -> кореневий CA (GTS Root R1).

### 4.2. Аналіз github.com

```
$ echo | openssl s_client -connect github.com:443 2>/dev/null | \
    grep -E "(Protocol|Cipher|Verify)"
    Protocol  : TLSv1.3
    Cipher    : TLS_AES_128_GCM_SHA256
    Verify return code: 0 (ok)
```

**Ланцюжок сертифікатів:**

```
$ echo | openssl s_client -connect github.com:443 -showcerts 2>/dev/null | \
    grep -E "(s:|i:)" | head -6
 0 s:C = US, ST = California, L = San Francisco, O = "GitHub, Inc.", CN = github.com
   i:C = US, O = DigiCert Inc, CN = DigiCert Global G2 TLS RSA SHA256 2020 CA1
 1 s:C = US, O = DigiCert Inc, CN = DigiCert Global G2 TLS RSA SHA256 2020 CA1
   i:C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert Global Root G2
```

**Пояснення:** GitHub також використовує TLS 1.3, але з шифром AES-128-GCM. Сертифікат виданий комерційним CA DigiCert для конкретного домену github.com.

### 4.3. Порівняння TLS-з'єднань

| Параметр | google.com | github.com |
|----------|-----------|------------|
| Версія TLS | TLS 1.3 | TLS 1.3 |
| Набір шифрів | TLS_AES_256_GCM_SHA384 | TLS_AES_128_GCM_SHA256 |
| CA | Google Trust Services (власний) | DigiCert (комерційний) |
| Тип сертифіката | Wildcard (*.google.com) | Конкретний домен |
| Перевірка | OK (код 0) | OK (код 0) |

**Висновок:** Обидва сайти використовують TLS 1.3 з AEAD-шифрами. Google обирає AES-256 (сильніший ключ), а GitHub — AES-128. Обидва варіанти вважаються безпечними.

---

## 5. Крок 4. Порівняльна таблиця

| Параметр | Симетричне шифрування | Асиметричне шифрування |
|----------|----------------------|----------------------|
| Швидкість | Висока (у 100-1000 разів швидше) | Низька (значно повільніше) |
| Типова довжина ключа | 128, 256 біт (AES) | 2048, 4096 біт (RSA); 256 біт (ECDSA) |
| Основне призначення | Шифрування великих обсягів даних | Обмін ключами, цифровий підпис |
| Проблема обміну ключами | Є: обидві сторони повинні мати секретний ключ | Немає: публічний ключ можна передавати відкрито |
| Приклади алгоритмів | AES-256-GCM, ChaCha20-Poly1305 | RSA, ECDSA, Ed25519 |

---

## 6. Відповіді на контрольні питання

### 1. У чому різниця між симетричним та асиметричним шифруванням? Чому використовують гібридне шифрування?

**Симетричне шифрування** використовує один ключ для шифрування та дешифрування. Працює швидко, підходить для великих обсягів даних, але потребує безпечного каналу для передачі ключа.

**Асиметричне шифрування** використовує пару ключів (публічний та приватний). Вирішує проблему обміну ключами, підтримує цифровий підпис, але працює значно повільніше.

**Гібридне шифрування** (TLS, PGP) поєднує обидва підходи: генерується випадковий сесійний ключ AES, яким шифруються дані (швидко). Сам ключ AES шифрується публічним ключем одержувача (RSA/ECDH). Це забезпечує і швидкість, і безпечний обмін ключами.

### 2. Поясніть різницю між AES-CBC та AES-GCM. Що таке AEAD?

**CBC (Cipher Block Chaining)** — кожен блок XOR-ується з попереднім зашифрованим блоком. Забезпечує лише конфіденційність, але не цілісність. Зловмисник може модифікувати шифротекст без виявлення.

**GCM (Galois/Counter Mode)** — поєднує потокове шифрування з автентифікацією. Генерує authentication tag, який перевіряє цілісність при дешифруванні.

**AEAD (Authenticated Encryption with Associated Data)** — клас алгоритмів, що одночасно забезпечують конфіденційність, цілісність та автентичність. GCM є прикладом AEAD. Він безпечніший за CBC, оскільки виключає атаки на цілісність (padding oracle, bit-flipping).

### 3. Як працює цифровий підпис? Які три властивості він забезпечує?

Цифровий підпис забезпечує: **цілісність** (дані не змінені), **автентичність** (підпис створив власник ключа), **невідмовність** (автор не може заперечити підпис).

Процес створення: обчислюється хеш файлу (SHA-256), хеш шифрується приватним ключем відправника. Процес перевірки: обчислюється хеш отриманого файлу, підпис розшифровується публічним ключем, порівнюються два хеші. Якщо збігаються — підпис валідний.

Зміна одного байта файлу змінює хеш, і він перестає збігатися з хешем у підписі, тому перевірка завершується помилкою (Verification Failure).

### 4. Що таке ланцюжок сертифікатів? Яку роль відіграє Root CA?

**Ланцюжок сертифікатів** — це послідовність сертифікатів від сертифіката сервера до кореневого CA: сертифікат сервера -> проміжний CA -> кореневий CA. Кожен сертифікат підписаний CA вищого рівня.

**Root CA (кореневий центр сертифікації)** — довірена організація, чий самопідписаний сертифікат попередньо встановлений в операційних системах та браузерах. Root CA є якорем довіри — якщо сертифікат сервера можна прослідкувати до довіреного Root CA, то з'єднання вважається безпечним.

### 5. Чому TLS 1.0/1.1 небезпечні? Назвіть переваги TLS 1.3.

TLS 1.0 та 1.1 мають відомі вразливості (BEAST, POODLE), підтримують застарілі алгоритми (RC4, 3DES) та офіційно визнані застарілими (RFC 8996).

Переваги TLS 1.3:
1. **Швидший handshake** — 1 RTT замість 2 RTT у TLS 1.2, що прискорює встановлення з'єднання.
2. **Обов'язковий PFS (Perfect Forward Secrecy)** — навіть якщо приватний ключ сервера буде скомпрометований у майбутньому, раніше перехоплені сесії не зможуть бути розшифровані.
3. **Видалені застарілі алгоритми** — підтримуються лише сучасні AEAD-шифри (AES-GCM, ChaCha20-Poly1305).

---

## 7. Висновки

У ході виконання практичної роботи отримано практичні навички роботи з криптографічними інструментами:

1. **Симетричне шифрування (CyberChef):** виконано шифрування та дешифрування тексту алгоритмом AES-256 у режимах CBC та GCM. Встановлено, що GCM є безпечнішим завдяки authentication tag, який забезпечує перевірку цілісності (AEAD). Продемонстровано, що дешифрування з невірним ключем неможливе.

2. **Асиметричне шифрування (OpenSSL):** виконано генерацію пари ключів RSA (2048 біт), шифрування публічним ключем та дешифрування приватним. Створено та перевірено цифровий підпис — підтверджено, що будь-яка зміна файлу призводить до невалідності підпису.

3. **Аналіз TLS-з'єднань:** проаналізовано TLS-з'єднання з google.com та github.com. Обидва сайти використовують TLS 1.3 з AEAD-шифрами. Порівняно центри сертифікації та набори шифрів.

4. **Порівняння типів шифрування:** складено таблицю порівняння симетричного та асиметричного шифрування. У реальних системах (TLS) обидва підходи комбінуються через гібридне шифрування для забезпечення і швидкості, і безпечного обміну ключами.
