<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Лекція 4. Криптографічний захист ІКС — Захист ІКС</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <div class="overlay" id="overlay"></div>
    <button class="menu-toggle" id="menuToggle">☰</button>

    <nav class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <a href="../index.html">Технології захисту ІКС</a>
        </div>
        <div class="nav-section">
            <h3>Лекції</h3>
            <ul>
                <li><a href="../lectures/01.html">1. Вступ. ІКС як об'єкт захисту</a></li>
                <li><a href="../lectures/02.html">2. Моделювання загроз</a></li>
                <li><a href="../lectures/03.html">3. Політика безпеки та доступ</a></li>
                <li><a href="../lectures/04.html" class="active">4. Криптографічний захист</a></li>
                <li><a href="../lectures/05.html">5. Захист мережевої інфраструктури</a></li>
                <li><a href="../lectures/06.html">6. Захист кінцевих точок</a></li>
                <li><a href="../lectures/07.html">7. Zero Trust та SIEM</a></li>
                <li><a href="../lectures/08.html">8. Проєктування КСЗІ</a></li>
                <li><a href="../lectures/09.html">9. Впровадження та тестування</a></li>
                <li><a href="../lectures/10.html">10. Експлуатація та інциденти</a></li>
            </ul>
        </div>
        <div class="nav-section">
            <h3>Практичні</h3>
            <ul>
                <li><a href="../practicals/01.html">1. Моделювання загроз</a></li>
                <li><a href="../practicals/02.html">2. Політика безпеки</a></li>
                <li><a href="../practicals/03.html">3. Криптографічні засоби</a></li>
                <li><a href="../practicals/04.html">4. Міжмережевий екран</a></li>
                <li><a href="../practicals/05.html">5. VPN та захист каналів</a></li>
                <li><a href="../practicals/06.html">6. IDS/IPS</a></li>
                <li><a href="../practicals/07.html">7. SIEM-системи</a></li>
                <li><a href="../practicals/08.html">8. Проєктування КСЗІ</a></li>
                <li><a href="../practicals/09.html">9. Тестування захищеності</a></li>
                <li><a href="../practicals/10.html">10. Захист проєктів</a></li>
            </ul>
        </div>
        <div class="nav-section">
            <h3>Звіти</h3>
            <ul>
                <li><a href="../report-viewer.html">Приклади звітів</a></li>
            </ul>
        </div>
    </nav>

    <main class="content">
        <article>
            <h1>Лекція 4. Криптографічний захист ІКС</h1>
            <p class="subtitle">Симетричне та асиметричне шифрування, PKI, TLS та українські стандарти</p>

            <!-- ===== 1. Роль криптографії ===== -->
            <h2>1. Роль криптографії в системах захисту ІКС</h2>

            <p>Криптографія є фундаментальною технологією захисту інформаційно-комунікаційних систем (ІКС). Вона забезпечує виконання ключових властивостей інформаційної безпеки:</p>

            <ul>
                <li><strong>Конфіденційність (Confidentiality)</strong> — шифрування даних робить їх нечитабельними для неавторизованих сторін. Застосування: шифрування файлів, дисків, каналів зв'язку (TLS, IPsec, VPN).</li>
                <li><strong>Цілісність (Integrity)</strong> — хеш-функції та MAC (Message Authentication Code) дозволяють виявити будь-яку модифікацію даних. Застосування: контрольні суми файлів, HMAC у протоколах.</li>
                <li><strong>Автентичність (Authenticity)</strong> — електронний цифровий підпис (ЕЦП) підтверджує, що дані створені конкретним відправником. Застосування: підпис документів, коду, оновлень ПЗ.</li>
                <li><strong>Невідмовність (Non-repudiation)</strong> — ЕЦП забезпечує неможливість відмови відправника від своїх дій. Застосування: юридично значущий електронний документообіг.</li>
            </ul>

            <div class="info-box">
                <strong>Принцип Керкгоффса</strong>
                Стійкість криптографічної системи повинна базуватися виключно на секретності ключа, а не на секретності алгоритму. Усі сучасні криптографічні стандарти (AES, RSA, ДСТУ 7624) є відкритими та публічно доступними для аналізу. Це дозволяє світовій криптографічній спільноті перевіряти їхню стійкість.
            </div>

            <!-- ===== 2. Симетричне шифрування ===== -->
            <h2>2. Симетричне шифрування</h2>

            <p>У симетричному шифруванні один і той самий ключ використовується як для шифрування, так і для дешифрування. Це найшвидший тип шифрування, що застосовується для захисту великих обсягів даних.</p>

            <h3>2.1. Принципи блочного шифрування</h3>

            <p>Блочний шифр обробляє дані фіксованими блоками (зазвичай 128 або 256 біт). Відкритий текст розбивається на блоки, кожен з яких шифрується окремо (або з урахуванням попередніх блоків, залежно від режиму).</p>

            <h4>Мережі Фейстеля (Feistel Networks)</h4>
            <p>Класична конструкція блочного шифру, що використовується в DES, Blowfish та багатьох інших алгоритмах. Принцип роботи:</p>
            <ol>
                <li>Блок відкритого тексту розділяється на дві половини: L (ліву) та R (праву).</li>
                <li>На кожному раунді (ітерації) виконується операція: L(i+1) = R(i); R(i+1) = L(i) XOR F(R(i), K(i)), де F — раундова функція, K(i) — підключ раунду.</li>
                <li>Перевага: дешифрування використовує ту ж структуру, але з підключами в зворотному порядку.</li>
                <li>Стійкість забезпечується достатньою кількістю раундів (наприклад, DES — 16 раундів).</li>
            </ol>

            <p>AES (Rijndael) використовує іншу конструкцію — <strong>SPN (Substitution-Permutation Network)</strong>, яка забезпечує кращу паралелізацію та ефективність.</p>

            <h3>2.2. Режими шифрування</h3>

            <p>Режим шифрування визначає, як блочний шифр обробляє повідомлення, що складається з кількох блоків. Вибір режиму критично впливає на безпеку.</p>

            <h4>ECB (Electronic Codebook)</h4>
            <p>Найпростіший режим: кожен блок шифрується незалежно тим самим ключем.</p>
            <ul>
                <li><strong>Принцип:</strong> C(i) = E(K, P(i)) — кожен блок відкритого тексту P(i) шифрується окремо.</li>
                <li><strong>Проблема:</strong> однакові блоки відкритого тексту дають однакові блоки шифротексту. Це дозволяє виявляти паттерни у зашифрованих даних (відомий приклад — шифрування зображення у режимі ECB, де контури залишаються видимими).</li>
                <li><strong>Висновок:</strong> ECB не рекомендується для шифрування даних, довших за один блок.</li>
            </ul>

            <h4>CBC (Cipher Block Chaining)</h4>
            <p>Кожен блок XOR-ується з попереднім блоком шифротексту перед шифруванням.</p>
            <ul>
                <li><strong>Принцип:</strong> C(i) = E(K, P(i) XOR C(i-1)); C(0) = IV (вектор ініціалізації).</li>
                <li><strong>Переваги:</strong> однакові блоки відкритого тексту дають різні шифротексти (завдяки зчепленню). IV повинен бути випадковим та унікальним для кожного повідомлення.</li>
                <li><strong>Недоліки:</strong> не підтримує паралельне шифрування (кожен блок залежить від попереднього); чутливий до padding oracle attacks (POODLE).</li>
            </ul>

            <h4>CTR (Counter Mode)</h4>
            <p>Перетворює блочний шифр у потоковий: шифрується лічильник, а результат XOR-ується з відкритим текстом.</p>
            <ul>
                <li><strong>Принцип:</strong> C(i) = P(i) XOR E(K, Nonce || Counter(i)). Nonce (number used once) — унікальне значення для кожного повідомлення.</li>
                <li><strong>Переваги:</strong> підтримує паралельне шифрування та дешифрування; не потребує padding; можливий довільний доступ до зашифрованих блоків.</li>
                <li><strong>Недоліки:</strong> не забезпечує цілісність (потрібен додатковий MAC); повторне використання Nonce катастрофічно (розкриває XOR двох відкритих текстів).</li>
            </ul>

            <h4>GCM (Galois/Counter Mode)</h4>
            <p>Режим автентифікованого шифрування (AEAD — Authenticated Encryption with Associated Data): одночасно забезпечує конфіденційність та цілісність.</p>
            <ul>
                <li><strong>Принцип:</strong> поєднує CTR-шифрування з автентифікацією на основі множення в полі Галуа (GHASH). Генерує authentication tag, що захищає як шифротекст, так і додаткові дані (AAD — наприклад, заголовки пакетів).</li>
                <li><strong>Переваги:</strong> єдина операція для шифрування + автентифікації; висока продуктивність (апаратна підтримка AES-NI + PCLMULQDQ); стандарт для TLS 1.3.</li>
                <li><strong>Вимоги:</strong> IV/Nonce повинен бути унікальним (зазвичай 96 біт); повторне використання Nonce компрометує автентифікацію.</li>
            </ul>

            <h4>Порівняння режимів шифрування</h4>
            <table>
                <thead>
                    <tr>
                        <th>Характеристика</th>
                        <th>ECB</th>
                        <th>CBC</th>
                        <th>CTR</th>
                        <th>GCM</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Паралельне шифрування</strong></td>
                        <td>Так</td>
                        <td>Ні</td>
                        <td>Так</td>
                        <td>Так</td>
                    </tr>
                    <tr>
                        <td><strong>Паралельне дешифрування</strong></td>
                        <td>Так</td>
                        <td>Так</td>
                        <td>Так</td>
                        <td>Так</td>
                    </tr>
                    <tr>
                        <td><strong>Потребує padding</strong></td>
                        <td>Так</td>
                        <td>Так</td>
                        <td>Ні</td>
                        <td>Ні</td>
                    </tr>
                    <tr>
                        <td><strong>Автентифікація</strong></td>
                        <td>Ні</td>
                        <td>Ні</td>
                        <td>Ні</td>
                        <td>Так (AEAD)</td>
                    </tr>
                    <tr>
                        <td><strong>Приховує паттерни</strong></td>
                        <td>Ні</td>
                        <td>Так</td>
                        <td>Так</td>
                        <td>Так</td>
                    </tr>
                    <tr>
                        <td><strong>Чутливість до Nonce/IV</strong></td>
                        <td>Немає</td>
                        <td>Середня</td>
                        <td>Критична</td>
                        <td>Критична</td>
                    </tr>
                    <tr>
                        <td><strong>Рекомендація</strong></td>
                        <td>Не використовувати</td>
                        <td>Застаріває</td>
                        <td>Потрібен окремий MAC</td>
                        <td>Рекомендовано</td>
                    </tr>
                </tbody>
            </table>

            <h3>2.3. AES-256 (Advanced Encryption Standard)</h3>

            <p><code>AES</code> (Rijndael) — симетричний блочний шифр, обраний NIST у 2001 році як заміна DES. Підтримує розміри ключів 128, 192 та 256 біт при фіксованому розмірі блоку 128 біт.</p>

            <h4>Структура AES</h4>
            <p>AES-256 виконує 14 раундів (AES-128 — 10 раундів, AES-192 — 12 раундів). Кожен раунд складається з чотирьох операцій над матрицею стану 4x4 байти:</p>

            <ol>
                <li><strong>SubBytes (підстановка байтів)</strong> — кожен байт замінюється іншим за допомогою S-Box (таблиці підстановки). S-Box побудований на основі мультиплікативного оберненого елемента в полі GF(2^8) та афінного перетворення. Забезпечує нелінійність шифру.</li>
                <li><strong>ShiftRows (зсув рядків)</strong> — рядки матриці стану циклічно зсуваються: 1-й рядок не зсувається, 2-й — на 1 байт, 3-й — на 2 байти, 4-й — на 3 байти. Забезпечує дифузію між стовпцями.</li>
                <li><strong>MixColumns (змішування стовпців)</strong> — кожен стовпець множиться на фіксовану матрицю в полі GF(2^8). Забезпечує дифузію між рядками. Не виконується в останньому раунді.</li>
                <li><strong>AddRoundKey (додавання ключа раунду)</strong> — XOR матриці стану з підключем раунду (отриманим з основного ключа через Key Expansion).</li>
            </ol>

            <div class="info-box">
                <strong>Чому AES — світовий стандарт?</strong>
                AES обрано через: високу криптографічну стійкість (жодної практичної атаки за 25+ років); ефективну апаратну реалізацію (інструкції AES-NI у процесорах Intel/AMD); компактність (малий розмір коду для вбудованих систем); гнучкість (3 розміри ключа для різних рівнів безпеки). AES-256 забезпечує рівень безпеки 256 біт, що вважається стійким навіть до потенційних квантових атак (алгоритм Гровера зменшує стійкість удвічі, до 128 біт — все ще достатньо).
            </div>

            <h3>2.4. ДСТУ 7624:2014 (Калина) — український стандарт блочного шифрування</h3>

            <p><code>Калина</code> — національний стандарт блочного шифрування України, затверджений як ДСТУ 7624:2014. Розроблений у Харківському національному університеті ім. В.Н. Каразіна.</p>

            <h4>Особливості Калини</h4>
            <ul>
                <li><strong>Розміри блоку:</strong> 128, 256 або 512 біт (AES підтримує лише 128 біт).</li>
                <li><strong>Розміри ключа:</strong> рівні розміру блоку або подвійні (128, 256, 512 біт).</li>
                <li><strong>Кількість раундів:</strong> залежить від розміру блоку та ключа (10, 14 або 18 раундів).</li>
                <li><strong>Конструкція:</strong> SPN (Substitution-Permutation Network), подібна до AES, але з використанням чотирьох різних S-Box замість одного, що підвищує стійкість до алгебраїчних атак.</li>
                <li><strong>Операції:</strong> SubBytes (4 різних S-Box), ShiftRows, MixColumns, AddModKey (додавання ключа за модулем 2^64 замість XOR, що є відмінністю від AES).</li>
            </ul>

            <h4>Порівняння AES та Калини</h4>
            <table>
                <thead>
                    <tr>
                        <th>Характеристика</th>
                        <th>AES (Rijndael)</th>
                        <th>ДСТУ 7624 (Калина)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Розмір блоку</strong></td>
                        <td>128 біт</td>
                        <td>128, 256, 512 біт</td>
                    </tr>
                    <tr>
                        <td><strong>Розмір ключа</strong></td>
                        <td>128, 192, 256 біт</td>
                        <td>128, 256, 512 біт</td>
                    </tr>
                    <tr>
                        <td><strong>Конструкція</strong></td>
                        <td>SPN</td>
                        <td>SPN</td>
                    </tr>
                    <tr>
                        <td><strong>S-Box</strong></td>
                        <td>1</td>
                        <td>4 різних</td>
                    </tr>
                    <tr>
                        <td><strong>Додавання ключа</strong></td>
                        <td>XOR</td>
                        <td>Додавання за mod 2^64 + XOR</td>
                    </tr>
                    <tr>
                        <td><strong>Апаратна підтримка</strong></td>
                        <td>AES-NI (повсюдно)</td>
                        <td>Обмежена</td>
                    </tr>
                    <tr>
                        <td><strong>Сфера застосування</strong></td>
                        <td>Міжнародний стандарт</td>
                        <td>Україна (ДСК та вище)</td>
                    </tr>
                </tbody>
            </table>

            <div class="tip-box">
                <strong>Практичне значення</strong>
                Для захисту інформації, що є власністю держави (гриф "ДСК" та вище), в Україні обов'язковим є застосування ДСТУ 7624 (Калина). Для комерційних систем та міжнародних комунікацій зазвичай використовується AES-256-GCM.
            </div>

            <!-- ===== 3. Асиметричне шифрування ===== -->
            <h2>3. Асиметричне шифрування</h2>

            <p>Асиметричне (або шифрування з відкритим ключем) використовує пару ключів: <strong>відкритий ключ (public key)</strong> для шифрування та <strong>закритий ключ (private key)</strong> для дешифрування. Обчислення закритого ключа з відкритого має бути обчислювально неможливим.</p>

            <h3>3.1. RSA (Rivest-Shamir-Adleman)</h3>

            <p><code>RSA</code> — найвідоміший алгоритм асиметричного шифрування, запропонований у 1977 році. Його стійкість базується на складності задачі факторизації великих чисел.</p>

            <h4>Математичні основи RSA</h4>
            <ol>
                <li><strong>Генерація ключів:</strong>
                    <ul>
                        <li>Обираються два великих простих числа p та q (кожне 1024+ біт для RSA-2048).</li>
                        <li>Обчислюється n = p * q (модуль RSA).</li>
                        <li>Обчислюється функція Ейлера: phi(n) = (p - 1)(q - 1).</li>
                        <li>Обирається відкрита експонента e, взаємно проста з phi(n) (зазвичай e = 65537 = 2^16 + 1).</li>
                        <li>Обчислюється закрита експонента d = e^(-1) mod phi(n) (мультиплікативний обернений).</li>
                        <li><strong>Відкритий ключ:</strong> (n, e). <strong>Закритий ключ:</strong> (n, d).</li>
                    </ul>
                </li>
                <li><strong>Шифрування:</strong> C = M^e mod n (де M — повідомлення як число, 0 <= M < n).</li>
                <li><strong>Дешифрування:</strong> M = C^d mod n.</li>
            </ol>

            <h4>Розміри ключів RSA та рівень безпеки</h4>
            <table>
                <thead>
                    <tr>
                        <th>Розмір ключа RSA</th>
                        <th>Еквівалент симетричного ключа</th>
                        <th>Рекомендація</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>1024 біт</td>
                        <td>~80 біт</td>
                        <td>Небезпечний, не використовувати</td>
                    </tr>
                    <tr>
                        <td>2048 біт</td>
                        <td>~112 біт</td>
                        <td>Мінімально допустимий (до ~2030)</td>
                    </tr>
                    <tr>
                        <td>3072 біт</td>
                        <td>~128 біт</td>
                        <td>Рекомендований</td>
                    </tr>
                    <tr>
                        <td>4096 біт</td>
                        <td>~140+ біт</td>
                        <td>Довгострокова безпека</td>
                    </tr>
                </tbody>
            </table>

            <div class="warning-box">
                <strong>RSA та квантові обчислення</strong>
                Алгоритм Шора дозволяє факторизувати великі числа за поліноміальний час на квантовому комп'ютері, що робить RSA вразливим до квантових атак. NIST активно стандартизує постквантові криптографічні алгоритми (ML-KEM, ML-DSA). Для нових систем з довгостроковими вимогами до безпеки варто планувати міграцію на постквантову криптографію.
            </div>

            <h3>3.2. ECC (Elliptic Curve Cryptography) — криптографія на еліптичних кривих</h3>

            <p>ECC базується на складності задачі дискретного логарифмування в групі точок еліптичної кривої (ECDLP — Elliptic Curve Discrete Logarithm Problem). Головна перевага ECC — досягнення такого ж рівня безпеки, як RSA, при значно менших розмірах ключів.</p>

            <h4>Порівняння розмірів ключів</h4>
            <table>
                <thead>
                    <tr>
                        <th>Рівень безпеки (біт)</th>
                        <th>RSA (біт)</th>
                        <th>ECC (біт)</th>
                        <th>Співвідношення</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>80</td>
                        <td>1024</td>
                        <td>160</td>
                        <td>6.4:1</td>
                    </tr>
                    <tr>
                        <td>112</td>
                        <td>2048</td>
                        <td>224</td>
                        <td>9.1:1</td>
                    </tr>
                    <tr>
                        <td>128</td>
                        <td>3072</td>
                        <td>256</td>
                        <td>12:1</td>
                    </tr>
                    <tr>
                        <td>192</td>
                        <td>7680</td>
                        <td>384</td>
                        <td>20:1</td>
                    </tr>
                    <tr>
                        <td>256</td>
                        <td>15360</td>
                        <td>512</td>
                        <td>30:1</td>
                    </tr>
                </tbody>
            </table>

            <h4>Основні алгоритми на основі ECC</h4>
            <ul>
                <li><strong>ECDSA (Elliptic Curve Digital Signature Algorithm)</strong> — алгоритм цифрового підпису на еліптичних кривих. Використовується в TLS, Bitcoin, SSH. Стандартні криві: P-256 (secp256r1), P-384 (secp384r1).</li>
                <li><strong>ECDH (Elliptic Curve Diffie-Hellman)</strong> — протокол узгодження спільного секрету між двома сторонами без передачі ключа через канал зв'язку. Кожна сторона генерує свою пару ключів, обмінюється публічними ключами, та обчислює спільний секрет.</li>
                <li><strong>EdDSA (Edwards-curve Digital Signature Algorithm)</strong> — сучасна альтернатива ECDSA, що працює на кривих Едвардса (Ed25519, Ed448). Переваги: детерміністичний (не потребує генератора випадкових чисел при підписі), стійкий до side-channel attacks.</li>
            </ul>

            <h3>3.3. ДСТУ 4145-2002 — український стандарт ЕЦП</h3>

            <p><code>ДСТУ 4145-2002</code> — національний стандарт електронного цифрового підпису України, заснований на еліптичних кривих над полем GF(2^m) (бінарне поле). Використовується для Кваліфікованого Електронного Підпису (КЕП) в українських державних системах.</p>

            <h4>Особливості ДСТУ 4145-2002</h4>
            <ul>
                <li><strong>Базове поле:</strong> GF(2^m), де m = 163, 167, 173, 179, 191, 233, 257, 307, 367, 431 (на відміну від більшості міжнародних стандартів, що використовують прості поля GF(p)).</li>
                <li><strong>Розмір підпису:</strong> залежить від обраного поля (наприклад, для m=257 — 514 біт).</li>
                <li><strong>Застосування:</strong> КЕП для державних органів України, електронний документообіг, податкова звітність, система Дія.</li>
                <li><strong>Реалізації:</strong> бібліотеки ІІТ (Інститут інформаційних технологій), програмні засоби "Криптокомплект" та "AVEST".</li>
            </ul>

            <!-- ===== 4. Хеш-функції ===== -->
            <h2>4. Хеш-функції</h2>

            <p>Криптографічна хеш-функція — це одностороння функція, що перетворює вхідні дані довільної довжини у вихід фіксованої довжини (дайджест, hash). Гарна хеш-функція повинна задовольняти такі властивості:</p>

            <ul>
                <li><strong>Стійкість до першого прообразу (Preimage Resistance)</strong> — маючи хеш h, обчислювально неможливо знайти повідомлення M таке, що H(M) = h.</li>
                <li><strong>Стійкість до другого прообразу (Second Preimage Resistance)</strong> — маючи повідомлення M1, обчислювально неможливо знайти M2 (M2 != M1) таке, що H(M1) = H(M2).</li>
                <li><strong>Стійкість до колізій (Collision Resistance)</strong> — обчислювально неможливо знайти будь-яку пару M1 та M2 (M1 != M2) таких, що H(M1) = H(M2).</li>
                <li><strong>Лавинний ефект (Avalanche Effect)</strong> — зміна одного біта вхідних даних повинна змінити приблизно 50% бітів хешу.</li>
            </ul>

            <h3>4.1. SHA-256 (Secure Hash Algorithm)</h3>
            <p>SHA-256 належить до сімейства SHA-2, розробленого NSA та стандартизованого NIST (FIPS 180-4). Генерує 256-бітний (32-байтний) дайджест. Широко використовується в TLS, цифрових підписах, Bitcoin, перевірці цілісності файлів.</p>

            <h3>4.2. SHA-3 (Keccak)</h3>
            <p>SHA-3 — стандарт NIST (FIPS 202), заснований на конструкції Sponge. Принципово відрізняється від SHA-2 за внутрішньою будовою, що забезпечує диверсифікацію: навіть якщо буде знайдена вразливість у SHA-2, SHA-3 залишиться стійким. Варіанти: SHA3-256, SHA3-512, SHAKE128, SHAKE256 (extendable output).</p>

            <h3>4.3. ДСТУ 7564:2014 (Купина) — українська хеш-функція</h3>

            <p><code>Купина</code> — національна криптографічна хеш-функція України, стандартизована як ДСТУ 7564:2014. Розроблена у Харківському національному університеті ім. В.Н. Каразіна.</p>

            <ul>
                <li><strong>Розміри дайджесту:</strong> 256, 384 або 512 біт.</li>
                <li><strong>Конструкція:</strong> заснована на модифікованій конструкції Меркла-Дамгарда (Davies-Meyer) з використанням блочного шифру Калина як функції стиснення.</li>
                <li><strong>Застосування:</strong> обов'язкова для використання у державних системах України спільно з ДСТУ 4145-2002 (ЕЦП).</li>
            </ul>

            <h4>Порівняння хеш-функцій</h4>
            <table>
                <thead>
                    <tr>
                        <th>Характеристика</th>
                        <th>SHA-256</th>
                        <th>SHA-3 (256)</th>
                        <th>Купина-256</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Розмір дайджесту</strong></td>
                        <td>256 біт</td>
                        <td>256 біт</td>
                        <td>256 біт</td>
                    </tr>
                    <tr>
                        <td><strong>Конструкція</strong></td>
                        <td>Меркл-Дамгард</td>
                        <td>Sponge (Keccak)</td>
                        <td>Модифікований Меркл-Дамгард</td>
                    </tr>
                    <tr>
                        <td><strong>Розмір блоку</strong></td>
                        <td>512 біт</td>
                        <td>1088 біт (r=1088)</td>
                        <td>512 біт</td>
                    </tr>
                    <tr>
                        <td><strong>Стійкість до колізій</strong></td>
                        <td>128 біт</td>
                        <td>128 біт</td>
                        <td>128 біт</td>
                    </tr>
                    <tr>
                        <td><strong>Продуктивність (SW)</strong></td>
                        <td>Висока (SHA-NI)</td>
                        <td>Середня</td>
                        <td>Середня</td>
                    </tr>
                    <tr>
                        <td><strong>Стандарт</strong></td>
                        <td>NIST FIPS 180-4</td>
                        <td>NIST FIPS 202</td>
                        <td>ДСТУ 7564:2014</td>
                    </tr>
                    <tr>
                        <td><strong>Застосування</strong></td>
                        <td>Міжнародний</td>
                        <td>Міжнародний</td>
                        <td>Україна</td>
                    </tr>
                </tbody>
            </table>

            <!-- ===== 5. PKI ===== -->
            <h2>5. PKI — інфраструктура відкритих ключів</h2>

            <p>PKI (Public Key Infrastructure) — сукупність апаратних та програмних засобів, політик та процедур, необхідних для створення, управління, зберігання, розповсюдження та відкликання цифрових сертифікатів. PKI забезпечує довіру між сторонами, які ніколи не зустрічалися.</p>

            <h3>5.1. Сертифікати X.509</h3>

            <p>Сертифікат X.509 — це цифровий документ, що пов'язує відкритий ключ з ідентичністю його власника. Сертифікат підписаний Центром Сертифікації (CA — Certificate Authority).</p>

            <h4>Структура сертифіката X.509 v3</h4>
            <table>
                <thead>
                    <tr>
                        <th>Поле</th>
                        <th>Опис</th>
                        <th>Приклад</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Version</strong></td>
                        <td>Версія стандарту</td>
                        <td>v3 (найпоширеніша)</td>
                    </tr>
                    <tr>
                        <td><strong>Serial Number</strong></td>
                        <td>Унікальний номер сертифіката</td>
                        <td>03:A1:F2:...</td>
                    </tr>
                    <tr>
                        <td><strong>Signature Algorithm</strong></td>
                        <td>Алгоритм підпису CA</td>
                        <td>SHA256withRSA, ECDSA-with-SHA384</td>
                    </tr>
                    <tr>
                        <td><strong>Issuer</strong></td>
                        <td>DN Центру Сертифікації</td>
                        <td>CN=Company CA, O=Company, C=UA</td>
                    </tr>
                    <tr>
                        <td><strong>Validity</strong></td>
                        <td>Термін дії (Not Before / Not After)</td>
                        <td>2025-01-01 / 2026-01-01</td>
                    </tr>
                    <tr>
                        <td><strong>Subject</strong></td>
                        <td>DN власника сертифіката</td>
                        <td>CN=www.company.ua, O=Company</td>
                    </tr>
                    <tr>
                        <td><strong>Subject Public Key</strong></td>
                        <td>Відкритий ключ та алгоритм</td>
                        <td>RSA 2048 bit / EC P-256</td>
                    </tr>
                    <tr>
                        <td><strong>Extensions</strong></td>
                        <td>Розширення v3</td>
                        <td>SAN, Key Usage, Basic Constraints</td>
                    </tr>
                    <tr>
                        <td><strong>Signature</strong></td>
                        <td>Цифровий підпис CA</td>
                        <td>(бінарні дані підпису)</td>
                    </tr>
                </tbody>
            </table>

            <h4>Важливі розширення X.509 v3</h4>
            <ul>
                <li><strong>Subject Alternative Name (SAN)</strong> — додаткові імена (DNS, IP, email), для яких дійсний сертифікат. У сучасних браузерах це основне поле для перевірки імені.</li>
                <li><strong>Key Usage</strong> — допустиме використання ключа (digitalSignature, keyEncipherment, keyCertSign).</li>
                <li><strong>Extended Key Usage (EKU)</strong> — конкретні застосування (serverAuth, clientAuth, codeSigning).</li>
                <li><strong>Basic Constraints</strong> — вказує, чи є сертифікат CA-сертифікатом (cA:TRUE) та максимальну глибину ланцюжка.</li>
                <li><strong>CRL Distribution Points</strong> — URL для завантаження списку відкликаних сертифікатів.</li>
                <li><strong>Authority Information Access (AIA)</strong> — URL для OCSP та проміжного CA-сертифіката.</li>
            </ul>

            <h3>5.2. Ієрархія CA та ланцюжки сертифікатів</h3>

            <p>PKI зазвичай будується як ієрархія довіри:</p>

            <ul>
                <li><strong>Root CA (Кореневий CA)</strong> — найвищий рівень довіри. Його сертифікат самопідписаний та попередньо встановлений у операційних системах і браузерах ("trust store"). Root CA зазвичай перебуває в offline-режимі для максимальної безпеки.</li>
                <li><strong>Intermediate CA (Проміжний CA)</strong> — підписаний Root CA. Виконує повсякденну роботу з видачі сертифікатів. Компрометація Intermediate CA не компрометує Root CA — достатньо відкликати проміжний сертифікат.</li>
                <li><strong>End-Entity Certificate (Кінцевий сертифікат)</strong> — сертифікат сервера, користувача або пристрою. Підписаний Intermediate CA.</li>
            </ul>

            <p><strong>Ланцюжок довіри (Certificate Chain):</strong> End-Entity -> Intermediate CA -> Root CA. Клієнт перевіряє кожен підпис у ланцюжку та підтверджує, що Root CA знаходиться у його trust store.</p>

            <h3>5.3. Відкликання сертифікатів: CRL та OCSP</h3>

            <p>Сертифікат може бути відкликаний до закінчення терміну дії (наприклад, при компрометації закритого ключа). Існують два механізми перевірки відкликання:</p>

            <table>
                <thead>
                    <tr>
                        <th>Характеристика</th>
                        <th>CRL (Certificate Revocation List)</th>
                        <th>OCSP (Online Certificate Status Protocol)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Принцип</strong></td>
                        <td>CA публікує підписаний список серійних номерів відкликаних сертифікатів</td>
                        <td>Клієнт надсилає запит до OCSP-респондера з серійним номером сертифіката</td>
                    </tr>
                    <tr>
                        <td><strong>Відповідь</strong></td>
                        <td>Повний список (може бути великим)</td>
                        <td>Статус одного сертифіката (Good / Revoked / Unknown)</td>
                    </tr>
                    <tr>
                        <td><strong>Актуальність</strong></td>
                        <td>Оновлюється періодично (годинах/днях)</td>
                        <td>Реальний час (або кешований — OCSP Stapling)</td>
                    </tr>
                    <tr>
                        <td><strong>Навантаження на мережу</strong></td>
                        <td>Великий файл CRL при масштабуванні</td>
                        <td>Малий запит/відповідь</td>
                    </tr>
                    <tr>
                        <td><strong>Конфіденційність</strong></td>
                        <td>Не розкриває, які сертифікати перевіряються</td>
                        <td>OCSP-респондер бачить, які сайти відвідуються (вирішується OCSP Stapling)</td>
                    </tr>
                </tbody>
            </table>

            <div class="tip-box">
                <strong>OCSP Stapling</strong>
                OCSP Stapling вирішує проблему конфіденційності та продуктивності: сервер сам періодично запитує OCSP-статус свого сертифіката та "прикріплює" (staple) підписану OCSP-відповідь до TLS-handshake. Клієнту не потрібно звертатися до OCSP-респондера окремо.
            </div>

            <!-- ===== 6. Практичне застосування ===== -->
            <h2>6. Практичне застосування криптографії</h2>

            <h3>6.1. TLS 1.3 — захист каналів зв'язку</h3>

            <p><code>TLS 1.3</code> (RFC 8446) — найновіша версія протоколу Transport Layer Security, що забезпечує конфіденційність та цілісність даних між двома сторонами. TLS 1.3 значно спрощений та безпечніший порівняно з попередніми версіями.</p>

            <h4>Ключові покращення TLS 1.3</h4>
            <ul>
                <li>Видалено небезпечні алгоритми: RSA key exchange (немає forward secrecy), CBC mode ciphers, RC4, SHA-1, MD5, DES, 3DES.</li>
                <li>Залишено лише AEAD-шифри: AES-128-GCM, AES-256-GCM, ChaCha20-Poly1305.</li>
                <li>Обов'язковий Forward Secrecy: тільки (EC)DHE для обміну ключами.</li>
                <li>Зменшена кількість round-trips: 1-RTT handshake (замість 2-RTT у TLS 1.2).</li>
                <li>Підтримка 0-RTT (early data) для повторних з'єднань (з обмеженнями щодо replay protection).</li>
            </ul>

            <h4>TLS 1.3 Handshake (1-RTT)</h4>
            <ol>
                <li><strong>ClientHello:</strong> клієнт надсилає підтримувані cipher suites, key_share (публічний ключ ECDHE), та supported_groups (криві). У TLS 1.3 клієнт одразу надсилає ключовий матеріал (спекулятивно, для найпоширенішої кривої).</li>
                <li><strong>ServerHello + EncryptedExtensions + Certificate + CertificateVerify + Finished:</strong>
                    <ul>
                        <li>Сервер обирає cipher suite та повертає свій key_share.</li>
                        <li>З цього моменту все шифрується (handshake keys, обчислені з ECDHE).</li>
                        <li>Сервер надсилає свій сертифікат та CertificateVerify (підпис handshake).</li>
                        <li>Finished — MAC від усіх handshake-повідомлень для верифікації цілісності.</li>
                    </ul>
                </li>
                <li><strong>Client Finished:</strong> клієнт перевіряє сертифікат сервера, обчислює session keys та надсилає Finished.</li>
                <li><strong>Application Data:</strong> сторони обмінюються даними, зашифрованими session keys.</li>
            </ol>

            <h4>Cipher Suites у TLS 1.3</h4>
            <pre><code># TLS 1.3 визначає лише 5 cipher suites:
TLS_AES_128_GCM_SHA256          # Найпоширеніший
TLS_AES_256_GCM_SHA384          # Підвищена безпека
TLS_CHACHA20_POLY1305_SHA256    # Оптимізований для мобільних пристроїв
TLS_AES_128_CCM_SHA256          # IoT-пристрої
TLS_AES_128_CCM_8_SHA256        # IoT з обмеженими ресурсами

# Key exchange: завжди (EC)DHE
# Signature: RSA-PSS, ECDSA, EdDSA</code></pre>

            <div class="info-box">
                <strong>0-RTT (Early Data)</strong>
                TLS 1.3 підтримує 0-RTT: при повторному з'єднанні клієнт може надіслати дані разом з ClientHello, використовуючи PSK (Pre-Shared Key) з попередньої сесії. Це зменшує затримку, але 0-RTT дані вразливі до replay-атак (їх можна перенаправити). Тому 0-RTT слід використовувати тільки для ідемпотентних запитів (GET), але не для операцій, що змінюють стан (POST).
            </div>

            <h3>6.2. IPsec — захист на мережевому рівні</h3>

            <p><code>IPsec</code> — набір протоколів для захисту IP-комунікацій на мережевому рівні (Layer 3). На відміну від TLS, що працює на транспортному рівні та захищає окремі з'єднання, IPsec захищає весь IP-трафік між вузлами.</p>

            <h4>Режими IPsec</h4>
            <table>
                <thead>
                    <tr>
                        <th>Характеристика</th>
                        <th>Transport Mode</th>
                        <th>Tunnel Mode</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Що шифрується</strong></td>
                        <td>Лише payload (дані) IP-пакету</td>
                        <td>Весь оригінальний IP-пакет (з заголовком)</td>
                    </tr>
                    <tr>
                        <td><strong>IP-заголовок</strong></td>
                        <td>Оригінальний (видимий)</td>
                        <td>Новий зовнішній заголовок</td>
                    </tr>
                    <tr>
                        <td><strong>Типове застосування</strong></td>
                        <td>Host-to-host (між двома серверами)</td>
                        <td>Site-to-site VPN (між маршрутизаторами)</td>
                    </tr>
                    <tr>
                        <td><strong>Приховує топологію</strong></td>
                        <td>Ні</td>
                        <td>Так (внутрішні IP-адреси приховані)</td>
                    </tr>
                </tbody>
            </table>

            <h4>Протоколи IPsec</h4>
            <ul>
                <li><strong>ESP (Encapsulating Security Payload)</strong> — забезпечує конфіденційність (шифрування), цілісність та автентифікацію даних. Протокол IP 50. Найпоширеніший компонент IPsec.</li>
                <li><strong>AH (Authentication Header)</strong> — забезпечує лише цілісність та автентифікацію (без шифрування). Протокол IP 51. Використовується рідко, оскільки ESP може виконувати ті ж функції.</li>
                <li><strong>IKEv2 (Internet Key Exchange v2)</strong> — протокол для автоматичного узгодження параметрів безпеки (Security Association) та обміну ключами. Порт UDP 500 (та 4500 для NAT-Traversal).</li>
            </ul>

            <h4>Фази IKEv2</h4>
            <ol>
                <li><strong>IKE_SA_INIT:</strong> узгодження криптографічних параметрів, обмін ключами (DH/ECDH), генерація IKE SA (Security Association). Всього 2 повідомлення (1 round trip).</li>
                <li><strong>IKE_AUTH:</strong> взаємна автентифікація (сертифікати, PSK або EAP), створення першого CHILD SA (для ESP/AH). Зашифровано ключами з фази 1.</li>
                <li><strong>CREATE_CHILD_SA:</strong> створення додаткових SA або rekeying існуючих.</li>
            </ol>

            <h3>6.3. Практичні команди OpenSSL</h3>

            <p><code>OpenSSL</code> — відкрита бібліотека та набір утиліт командного рядка для роботи з криптографічними алгоритмами, SSL/TLS протоколами та PKI.</p>

            <h4>Генерація ключів</h4>

            <pre><code># === Симетричне шифрування ===

# Генерація випадкового ключа AES-256 (32 байти = 256 біт)
openssl rand -hex 32

# Генерація випадкового IV (16 байт = 128 біт для AES)
openssl rand -hex 16

# Шифрування файлу AES-256-GCM (з паролем)
openssl enc -aes-256-gcm -salt -pbkdf2 -iter 100000 \
    -in secret.txt -out secret.enc

# Дешифрування
openssl enc -d -aes-256-gcm -salt -pbkdf2 -iter 100000 \
    -in secret.enc -out secret_decrypted.txt

# Шифрування файлу AES-256-CBC з явним ключем та IV
openssl enc -aes-256-cbc \
    -K 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f \
    -iv 000102030405060708090a0b0c0d0e0f \
    -in plaintext.txt -out ciphertext.bin</code></pre>

            <h4>Генерація ключів RSA та ECC</h4>

            <pre><code># === RSA ===

# Генерація приватного ключа RSA-4096
openssl genpkey -algorithm RSA -out private_rsa.pem \
    -pkeyopt rsa_keygen_bits:4096

# Витягнення публічного ключа
openssl pkey -in private_rsa.pem -pubout -out public_rsa.pem

# Перегляд деталей ключа
openssl pkey -in private_rsa.pem -text -noout

# RSA шифрування (лише для невеликих даних, до 446 байт для RSA-4096)
openssl pkeyutl -encrypt -pubin -inkey public_rsa.pem \
    -in small_message.txt -out encrypted.bin

# RSA дешифрування
openssl pkeyutl -decrypt -inkey private_rsa.pem \
    -in encrypted.bin -out decrypted.txt

# === ECC (Elliptic Curve) ===

# Список доступних кривих
openssl ecparam -list_curves

# Генерація приватного ключа ECDSA (крива P-256)
openssl genpkey -algorithm EC -out private_ec.pem \
    -pkeyopt ec_paramgen_curve:P-256

# Генерація ключа Ed25519
openssl genpkey -algorithm Ed25519 -out private_ed25519.pem

# Витягнення публічного ключа
openssl pkey -in private_ec.pem -pubout -out public_ec.pem</code></pre>

            <h4>Хешування</h4>

            <pre><code># SHA-256 хеш файлу
openssl dgst -sha256 document.pdf

# SHA-384 хеш
openssl dgst -sha384 document.pdf

# SHA3-256 хеш
openssl dgst -sha3-256 document.pdf

# HMAC-SHA256 (для автентифікації повідомлень)
openssl dgst -sha256 -hmac "SecretKey123" document.pdf

# Цифровий підпис файлу (RSA + SHA256)
openssl dgst -sha256 -sign private_rsa.pem -out signature.bin document.pdf

# Перевірка підпису
openssl dgst -sha256 -verify public_rsa.pem -signature signature.bin document.pdf

# Цифровий підпис ECDSA
openssl dgst -sha256 -sign private_ec.pem -out signature_ec.bin document.pdf

# Перевірка підпису ECDSA
openssl dgst -sha256 -verify public_ec.pem -signature signature_ec.bin document.pdf</code></pre>

            <h4>PKI: створення CSR та сертифікатів</h4>

            <pre><code># === Створення CSR (Certificate Signing Request) ===

# Генерація ключа + CSR в одній команді
openssl req -new -newkey rsa:4096 -nodes \
    -keyout server.key -out server.csr \
    -subj "/C=UA/ST=Kyiv/L=Kyiv/O=Company LLC/OU=IT/CN=www.company.ua"

# CSR з ECC ключем
openssl req -new -newkey ec -pkeyopt ec_paramgen_curve:P-256 -nodes \
    -keyout server_ec.key -out server_ec.csr \
    -subj "/C=UA/O=Company/CN=www.company.ua"

# Перегляд CSR
openssl req -in server.csr -text -noout -verify

# === Самопідписаний сертифікат (для тестування) ===
openssl req -x509 -newkey rsa:4096 -nodes -days 365 \
    -keyout self_signed.key -out self_signed.crt \
    -subj "/C=UA/O=TestOrg/CN=test.local" \
    -addext "subjectAltName=DNS:test.local,DNS:*.test.local,IP:192.168.1.10"

# === Створення мінімального CA ===

# 1. Генерація кореневого CA ключа та сертифіката
openssl req -x509 -newkey rsa:4096 -nodes -days 3650 \
    -keyout ca.key -out ca.crt \
    -subj "/C=UA/O=Company CA/CN=Company Root CA" \
    -addext "basicConstraints=critical,CA:TRUE" \
    -addext "keyUsage=critical,keyCertSign,cRLSign"

# 2. Підписання CSR сервера кореневим CA
openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key \
    -CAcreateserial -days 365 -sha256 \
    -extfile &lt;(printf "subjectAltName=DNS:www.company.ua,DNS:company.ua\n\
    keyUsage=digitalSignature,keyEncipherment\n\
    extendedKeyUsage=serverAuth") \
    -out server.crt

# 3. Перевірка ланцюжка сертифікатів
openssl verify -CAfile ca.crt server.crt

# Перегляд сертифіката
openssl x509 -in server.crt -text -noout</code></pre>

            <h4>Тестування TLS-з'єднань</h4>

            <pre><code># === Тестування TLS за допомогою s_client ===

# Підключення до HTTPS-сервера та перегляд сертифіката
openssl s_client -connect www.company.ua:443 -servername www.company.ua

# Відображення лише сертифіката
openssl s_client -connect www.company.ua:443 -servername www.company.ua \
    2>/dev/null | openssl x509 -text -noout

# Перевірка підтримки TLS 1.3
openssl s_client -connect www.company.ua:443 -tls1_3

# Перегляд ланцюжка сертифікатів
openssl s_client -connect www.company.ua:443 -showcerts

# Перевірка cipher suites
openssl s_client -connect www.company.ua:443 -cipher 'ECDHE-RSA-AES256-GCM-SHA384'

# Перевірка OCSP Stapling
openssl s_client -connect www.company.ua:443 -status

# Перевірка терміну дії сертифіката
echo | openssl s_client -connect www.company.ua:443 -servername www.company.ua \
    2>/dev/null | openssl x509 -noout -dates

# === Запуск тестового TLS-сервера (для тестування) ===
openssl s_server -cert server.crt -key server.key \
    -CAfile ca.crt -accept 4433 -www</code></pre>

            <div class="example-box">
                <strong>Приклад: перевірка TLS-конфігурації сервера</strong>
                <pre><code># Повний аналіз TLS-конфігурації сервера
$ openssl s_client -connect example.com:443 -servername example.com

# Ключова інформація у виводі:
# Protocol  : TLSv1.3
# Cipher    : TLS_AES_256_GCM_SHA384
# Server certificate:
#   subject: CN=example.com
#   issuer: CN=Let's Encrypt Authority X3
#   validity: Not After : Jun 15 2026
# Verify return code: 0 (ok)  &lt;-- сертифікат валідний</code></pre>
            </div>

            <!-- ===== 7. Підсумки ===== -->
            <h2>7. Підсумки</h2>

            <p>У цій лекції ми розглянули фундаментальні криптографічні технології, що застосовуються для захисту ІКС:</p>

            <ol>
                <li><strong>Симетричне шифрування:</strong>
                    <ul>
                        <li>AES-256-GCM — рекомендований стандарт (конфіденційність + цілісність).</li>
                        <li>ДСТУ 7624 (Калина) — обов'язковий для державних систем України.</li>
                        <li>Режим GCM переважає CBC завдяки автентифікованому шифруванню та паралелізації.</li>
                    </ul>
                </li>
                <li><strong>Асиметричне шифрування:</strong>
                    <ul>
                        <li>RSA — класичний, але потребує великих ключів (3072+ біт).</li>
                        <li>ECC — ефективніший (менші ключі, швидші операції).</li>
                        <li>ДСТУ 4145-2002 — український стандарт ЕЦП на еліптичних кривих.</li>
                    </ul>
                </li>
                <li><strong>Хеш-функції:</strong> SHA-256/SHA-3 — міжнародні стандарти; Купина (ДСТУ 7564) — український стандарт.</li>
                <li><strong>PKI:</strong> X.509 сертифікати, ієрархія CA, перевірка відкликання (CRL/OCSP).</li>
                <li><strong>TLS 1.3:</strong> сучасний стандарт захисту каналів зв'язку з 1-RTT handshake та обов'язковим forward secrecy.</li>
                <li><strong>IPsec:</strong> захист на мережевому рівні, transport vs tunnel mode, IKEv2.</li>
                <li><strong>OpenSSL:</strong> практичний інструмент для генерації ключів, сертифікатів та тестування TLS.</li>
            </ol>

            <div class="warning-box">
                <strong>Квантова загроза</strong>
                З розвитком квантових обчислень RSA та ECC стануть вразливими (алгоритм Шора). NIST стандартизував постквантові алгоритми: ML-KEM (Kyber) для інкапсуляції ключів та ML-DSA (Dilithium) для цифрових підписів. Рекомендується планувати "crypto agility" — здатність системи мігрувати на нові алгоритми без повної перебудови.
            </div>

            <div class="tip-box">
                <strong>Контрольні запитання</strong>
                <ol>
                    <li>Поясніть, чому режим ECB не рекомендується для шифрування даних.</li>
                    <li>У чому перевага GCM над CBC? Що таке AEAD?</li>
                    <li>Опишіть чотири операції одного раунду AES.</li>
                    <li>Чим ДСТУ 7624 (Калина) відрізняється від AES? У яких випадках її застосування обов'язкове?</li>
                    <li>Поясніть математичні основи RSA: як пов'язані p, q, n, e, d?</li>
                    <li>Чому ECC забезпечує ту ж стійкість, що й RSA, при менших розмірах ключів?</li>
                    <li>Опишіть структуру сертифіката X.509 v3 та поясніть роль SAN.</li>
                    <li>Поясніть потік TLS 1.3 handshake та його переваги над TLS 1.2.</li>
                    <li>У чому різниця між Transport та Tunnel режимами IPsec?</li>
                    <li>Напишіть послідовність команд OpenSSL для створення CA та підписання сертифіката сервера.</li>
                </ol>
            </div>

        </article>

        <nav class="page-nav">
            <a href="03.html">&larr; Політика безпеки та доступ</a>
            <a href="05.html">Захист мережевої інфраструктури &rarr;</a>
        </nav>
    </main>

    <script>
        document.getElementById('menuToggle').addEventListener('click', function() {
            document.getElementById('sidebar').classList.toggle('open');
            document.getElementById('overlay').classList.toggle('active');
        });
        document.getElementById('overlay').addEventListener('click', function() {
            document.getElementById('sidebar').classList.remove('open');
            this.classList.remove('active');
        });
    </script>
</body>
</html>
